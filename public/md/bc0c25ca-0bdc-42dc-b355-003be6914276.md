# Introduction to Serverless application development using Typescript.

Serverless is a recent buzz in the tech world. It offers a better way to manage resources than a non-serverless app. While the name has the potential to fool, it is necessary that one understands that it in no way is the absence of servers. It is just a fancy term for infrastructural abstraction. The infrastructural layer of a serverless app is abstracted from the developer by cloud providers as they focus on business logic and models.

A serverless application is in its most basic sense, a declaration of functions each of which executes a particular business feature or code. Using Javascript as point example, it is a usual approach to spin up an Expressjs or any other kind of server that would serve resources to clients but with the serverless approach, all you need is/are `functions`.

### Why you should adopt a serverless approach

* You'd be writing only functions or business logic.
* Deployed serverless apps run on a pay-as-you-use basis. This means you do not have to worry about service bills when there is less or no app use.
* You do not need to have a dedicated server which would run for long. Code is only executed as needed.


To begin development of serverless apps, there are necessary tools which would be leveraged on. Of utmost importance is the Serverless framework which is installable via `npm`. To install the necessary tool, run the following in your terminal:

```batch
npm install --global serverless serverless-offline
```

Running the above would install the Serverless framework globally and also install `serverless-offline`, a plugin that would be leveraged in running serverless apps offline. This is ideal so you wouldn't have to make a deployment with every change.

Once installed, the `serverless` executable is immediately available on the path and the command can be run to scaffold a new serverless project. Should you need to always clear doubts or read the serverless documentation again, you can get help [here](https://serverless.com).

We'll now proceed to bootstrap a serverless app using the installed framework. First, create a folder for files that would be generated and cd into the folder:

```batch
mkdir serverless-project && cd serverless-project
```

Next, run the `serverless` command to begin scaffolding the project:

```batch
serverless create --template aws-nodejs-typescript
```

The above command would create the project in the serverless-project folder using the `aws-nodejs-typescript` template. The folder structure would look something like the below image after the command is run:

![Image](/img/Screenshot%20(52).png)

Every file except [ `.prettierrc.json`, `.prettierignore`, `test.http`, `Readme.MD` ] is generated by running the command. To ensure the dependencies are available for use, run `npm install` in the project's root. The `serverless.ts` file is where you get to configure how deployments are done or how each function would be executed. Its content is as below:

```typescript
import type { Serverless } from "serverless/aws";

const serverlessConfiguration: Serverless = {
 service: {
  name: "serverless-typescript-learn"
  // app and org for use with dashboard.serverless.com
  // app: your-app-name,
  // org: your-org-name,
 },
 frameworkVersion: "2",
 custom: {
  webpack: {
   webpackConfig: "./webpack.config.js",
   includeModules: true
  }
 },
 // Add the serverless-webpack plugin
 plugins: ["serverless-webpack", "serverless-offline"],
 provider: {
  name: "aws",
  runtime: "nodejs12.x",
  apiGateway: {
   minimumCompressionSize: 1024
  },
  environment: {
   AWS_NODEJS_CONNECTION_REUSE_ENABLED: "1"
  }
 },
 functions: {
  hello: {
   handler: "handler.hello",
   events: [
    {
     http: {
      method: "get",
      path: "hello"
     }
    }
   ]
  },
  addUser: {
   handler: "handler.addUser",
   events: [
    {
     http: {
      method: "post",
      path: "add",
      cors: true
     }
    }
   ]
  }
 }
};

module.exports = serverlessConfiguration;
```

The `plugins` array doesn't include the serverless-offline plugin by default, you would have to include it so as to be able to leverage it. The `provider` object is where details about the service provider are provided. The `functions` object allow us to define our functions and their respective handlers. Each function could also be bound to specific events that trigger it. In the above example, several of the defined functions are bound to http events. 

It is time to show how these functions are actually defined and how they exceute code. For the scope of this article, I'll be showing how to do some actual database persistence. For this, it is necessary we define some models:

```typescript
import * as mongoose from "mongoose";

const UserSchema = new mongoose.Schema({
 name: {
  type: String,
  required: true
 },
 age: {
  type: Number,
  required: true
 }
});

const BookSchema = new mongoose.Schema({
 title: {
  type: String,
  required: true
 },
 content: {
  type: String,
  required: true
 },
 author: {
  type: mongoose.Schema.Types.ObjectId,
  ref: "User"
 }
});

const db = {
 users: mongoose.model("User", UserSchema),
 books: mongoose.model("Book", BookSchema)
};

export default db;
```

The above is the content of the `db.ts` file (please refer to image of folder structure). This file is where our models are defined. For that, `mongoose` (an ODM that enforces schema definition on mongodb) is leveraged. These models are then used in our handler file for some db operations.


```typescript
import { APIGatewayProxyHandler } from "aws-lambda";
import "source-map-support/register";
import * as mongoose from "mongoose";
import db from "./db";

mongoose.connect("mongodb://localhost:27017/ts_serverless").then(console.log);

export const hello: APIGatewayProxyHandler = async (event, _context) => {
 return {
  statusCode: 200,
  body: JSON.stringify(
   {
    message: "App is running",
    input: event
   },
   null,
   2
  )
 };
};

export const addUser: APIGatewayProxyHandler = async (event, _context) => {
 try {
  const user = await db.users.create({ ...JSON.parse(event.body) });
  return {
   statusCode: 201,
   body: JSON.stringify(
    {
     statusCode: 201,
     response: user
    },
    null,
    2
   )
  };
 } catch (error) {
  return {
   statusCode: 500,
   body: JSON.stringify({
    statusCode: 500,
    response: error.message
   })
  };
 }
};
```

The above is the content of the handler file. This file is where our functions are declared. The `hello` and `addUser` functions both return an `APIGatewayProxyHandler` object which requires the keys `statusCode` and `body`. The body is stringified and parsing to a json object is handled behind the scenes. Let us refer to our `serverless.ts` file to see how the configuration is made to include these functions.

```typescript
import type { Serverless } from "serverless/aws";

const serverlessConfiguration: Serverless = {
 service: {
  name: "serverless-typescript-learn"
  // app and org for use with dashboard.serverless.com
  // app: your-app-name,
  // org: your-org-name,
 },
 frameworkVersion: "2",
 custom: {
  webpack: {
   webpackConfig: "./webpack.config.js",
   includeModules: true
  }
 },
 // Add the serverless-webpack plugin
 plugins: ["serverless-webpack", "serverless-offline"],
 provider: {
  name: "aws",
  runtime: "nodejs12.x",
  apiGateway: {
   minimumCompressionSize: 1024
  },
  environment: {
   AWS_NODEJS_CONNECTION_REUSE_ENABLED: "1"
  }
 },
 functions: {
  hello: {
   handler: "handler.hello",
   events: [
    {
     http: {
      method: "get",
      path: "hello"
     }
    }
   ]
  },
  addUser: {
   handler: "handler.addUser",
   events: [
    {
     http: {
      method: "post",
      path: "add",
      cors: true
     }
    }
   ]
  }
 }
};

module.exports = serverlessConfiguration;
```

The `handler.addUser` handler is an indication that the handler for the `addUser` function is a function of same name that is present in the `handler.ts` file.

To run the app offline, enter the following into the terminal in the project's root and hit enter:

```batch
serverless offline
```

Running the above would present you with local endpoints that would serve as triggers for various defined functions. You may proceed to deploy the app to AWS by running `serverless deploy` but explaining further on is beyond the scope of this article.
